/*
Problem Statement

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers 
and are generated by the following formulae:
riangle P3,n=n(n+1)/2 1, 3, 6, 10, 15, …
Square P4,n=n2 1, 4, 9, 16, 25, …
Pentagonal P5,n=n(3n-1)/2 1, 5, 12, 22, 35, …
Hexagonal P6,n=n(2n-1) 1, 6, 15, 28, 45, …
Heptagonal P7,n=n(5n-3)/2 1, 7, 18, 34, 55, …
Octagonal P8,n=n(3n-2) 1, 8, 21, 40, 65, …

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.
1. The set is cyclic, in that the last two digits of each number is the first two digits of the next number (including the last number with the first).

2. Each polygonal type: triangle (P3,127=8128), square (P4,91=8281), and pentagonal (P5,44=2882), is represented by a different number in the set.

3. This is the only set of 4-digit numbers with this property.
Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: 
triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.


Solution:
-------------
I used a fairly efficient brute force method to find the solution. The algorithm goes
1. Generate all four digit  triangle, square, … , octagonal numbers
2. Start with any number as the beginning of the chain
3. Given the chain current find a number that
    > is cyclic as described
    > is not a type of number which is already used in the chain
    > is different from other numbers in the chain
4. If the chain is of length 6 check that it can be closed – if true then finish
5. If such a number exists add it to the chain and go to 3
6. If no such number exists remove the last number from the chain and go to 3.
*/

//
//#include<iostream>
//#include<vector>
//#include<list>
//#include<array>
//
//std::array<int, 6> solution;
////std::vector<std::vector<int>> numbers;
//int** numbers;
//
//
//bool FindNext(int last, int length) 
//{
//  for (int i = 0; i < solution.size(); i++)
//  {
//    if (solution[i] != 0) continue;
//    for (int j = 0; j < numbers[i].Length; j++)
//    {
//
//      bool unique = true;
//      for (int k = 0; k < solution.size(); k++)
//      {
//        if (numbers[i][j] == solution[k]) {
//          unique = false;
//          break;
//        }
//      }
//
//      if (unique && ((numbers[i][j] / 100) == (solution[last] % 100))) 
//      {
//        solution[i] = numbers[i][j];
//        if (length == 5) {
//          if (solution[5] / 100 == solution[i] % 100) return true;
//        }
//        if (FindNext(i, length + 1)) return true;
//      }
//    }
//    solution[i] = 0;
//  }
//  return false;
//}
//
////private void WriteStatus(){
////  Console.WriteLine("{0}, {1}, {2}, {3}, {4}, {5}", solution[0], solution[1], solution[2], solution[3], solution[4], solution[5]);
////}
//
//
//auto generateNumbers(int type) -> std::list<int>
//{
//  std::list<int> numbers;
//
//  int n = 0;
//  int number = 0;
//
//  while (number < 10000) 
//  {
//    n++;
//    switch (type) 
//    {
//    case 0:
//      //Triangle numbers
//      number = n * (n + 1) / 2;
//      break;
//    case 1:
//      // Square numbers
//      number = n * n;
//      break;
//    case 2:
//      // Pentagonal numbers
//      number = n * (3 * n - 1) / 2;
//      break;
//    case 3:
//      //Hexagonal numbers
//      number = n * (2 * n - 1);
//      break;
//    case 4:
//      //Heptagonal numbers
//      number = n * (5 * n - 3) / 2;
//      break;
//    case 5:
//      //Octagonal numbers
//      number = n * (3 * n - 2);
//      break;
//    }
//
//    if (number > 999)
//    {
//      numbers.push_back(number);
//    }
//  }
//
//  return numbers;
//}
//
//void BruteForce()
//{
//  int result(0);
//
//  numbers = new int[6][];
//
//  for (int i = 0; i < 6; i++) 
//  {
//    numbers[i] = generateNumbers(i);
//  }
//
//  for (int i = 0; i < numbers[5].Length; i++) 
//  {
//    solution[5] = numbers[5][i];
//    if (FindNext(5, 1)) break;
//  }
//
//  //result = solution.Sum();
//
//  //WriteStatus();
// // Console.WriteLine("The sum of the series is {0}", result);
//}

auto main() -> int
{
  //BruteForce();
  return 0;
}

